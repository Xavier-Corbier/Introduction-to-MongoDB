# **Session 3 - Partie 2 : Transactions et gestion de la cohÃ©rence**  

---

## **ğŸ¯ Objectifs pÃ©dagogiques**  

Ã€ la fin de cette session, vous serez capable de :  
âœ… Comprendre lâ€™importance des transactions en MongoDB.  
âœ… Utiliser les transactions ACID pour assurer la cohÃ©rence des donnÃ©es.  
âœ… ImplÃ©menter des transactions multi-documents.  
âœ… GÃ©rer les erreurs et assurer lâ€™intÃ©gritÃ© des opÃ©rations.  

---

## **ğŸ“š Contenu du cours**  

## **1ï¸âƒ£ Pourquoi utiliser des transactions en MongoDB ?**  

MongoDB est **NoSQL**, ce qui signifie que ses opÃ©rations sont gÃ©nÃ©ralement **non transactionnelles**.  
Cependant, certaines applications nÃ©cessitent des **transactions ACID** (AtomicitÃ©, CohÃ©rence, Isolation, DurabilitÃ©), par exemple :  

âœ” **SystÃ¨mes bancaires** (dÃ©bit/crÃ©dit sur deux comptes).  
âœ” **SystÃ¨mes e-commerce** (crÃ©ation d'une commande et dÃ©duction du stock).  
âœ” **Gestion des rÃ©servations** (vols, hÃ´tels, Ã©vÃ©nements).  

ğŸ“Œ **MongoDB supporte les transactions multi-documents** Ã  partir de la version **4.0** (uniquement sur les **Replica Sets**) et sur **Sharded Clusters** Ã  partir de MongoDB **4.2**.  

---

## **2ï¸âƒ£ Transactions ACID en MongoDB**  

### **ğŸ”¹ Explication des propriÃ©tÃ©s ACID**  

| PropriÃ©tÃ© | Description |
|-----------|------------|
| **AtomicitÃ© (A)** | Toutes les opÃ©rations dâ€™une transaction rÃ©ussissent ou sont annulÃ©es. |
| **CohÃ©rence (C)** | Les donnÃ©es restent valides avant et aprÃ¨s la transaction. |
| **Isolation (I)** | Une transaction en cours nâ€™affecte pas les autres transactions. |
| **DurabilitÃ© (D)** | Les modifications sont stockÃ©es de maniÃ¨re permanente aprÃ¨s validation. |

---

## **3ï¸âƒ£ Utilisation des transactions en MongoDB**  

### **ğŸ”¹ Syntaxe de base dâ€™une transaction**  
Une transaction en MongoDB utilise **les sessions**.  

```sh
// 1ï¸âƒ£ DÃ©marrer une session
session = db.getMongo().startSession()

// 2ï¸âƒ£ DÃ©marrer une transaction
session.startTransaction()

// 3ï¸âƒ£ ExÃ©cuter des opÃ©rations dans la transaction
session.getDatabase("ecommerce").commandes.insertOne(
  { "client_id": ObjectId("602d2149e773f2a3990b47f5"), "total": 150, "statut": "en attente" },
  { session: session }
)

session.getDatabase("ecommerce").stock.updateOne(
  { "produit_id": ObjectId("603d2149e773f2a3990b47a3") },
  { "$inc": { "quantite": -1 } },
  { session: session }
)

// 4ï¸âƒ£ Valider la transaction
session.commitTransaction()
session.endSession()
```

ğŸ“Œ **Explication** :  
âœ” Une **session** est crÃ©Ã©e pour regrouper les opÃ©rations.  
âœ” `startTransaction()` dÃ©marre la transaction.  
âœ” `commitTransaction()` valide toutes les opÃ©rations si elles rÃ©ussissent.  
âœ” `endSession()` termine la session proprement.  

---

### **ğŸ”¹ Annuler une transaction (`abortTransaction()`)**  
Si une erreur survient, la transaction peut Ãªtre annulÃ©e.  

```sh
session = db.getMongo().startSession()
session.startTransaction()

try {
  session.getDatabase("ecommerce").commandes.insertOne(
    { "client_id": ObjectId("602d2149e773f2a3990b47f5"), "total": 150 },
    { session: session }
  )

  // Provoquer une erreur (exemple : produit introuvable)
  session.getDatabase("ecommerce").stock.updateOne(
    { "produit_id": ObjectId("invalide") },
    { "$inc": { "quantite": -1 } },
    { session: session }
  )

  session.commitTransaction()
} catch (e) {
  print("Erreur dÃ©tectÃ©e, annulation de la transaction :", e)
  session.abortTransaction()
}

session.endSession()
```

ğŸ“Œ **Explication** :  
âœ” En cas dâ€™erreur, **toutes les opÃ©rations sont annulÃ©es** (`abortTransaction()`).  
âœ” Cela Ã©vite les incohÃ©rences (ex. : une commande crÃ©Ã©e sans mise Ã  jour du stock).  

---

## **4ï¸âƒ£ Transactions multi-collections**  

MongoDB permet de modifier **plusieurs collections** dans une mÃªme transaction.  

Exemple :  
1ï¸âƒ£ Ajouter une **commande**.  
2ï¸âƒ£ DÃ©duire les articles du **stock**.  
3ï¸âƒ£ CrÃ©er une **facture**.  

```sh
session = db.getMongo().startSession()
session.startTransaction()

try {
  // Ajout d'une commande
  session.getDatabase("ecommerce").commandes.insertOne(
    { "client_id": ObjectId("602d2149e773f2a3990b47f5"), "total": 200, "statut": "payÃ©e" },
    { session: session }
  )

  // Mise Ã  jour du stock
  session.getDatabase("ecommerce").stock.updateOne(
    { "produit_id": ObjectId("603d2149e773f2a3990b47a3") },
    { "$inc": { "quantite": -2 } },
    { session: session }
  )

  // Ajout d'une facture
  session.getDatabase("ecommerce").factures.insertOne(
    { "commande_id": ObjectId("605d2149e773f2a3990b47b2"), "montant": 200 },
    { session: session }
  )

  session.commitTransaction()
} catch (e) {
  session.abortTransaction()
  print("Transaction annulÃ©e :", e)
}

session.endSession()
```

ğŸ“Œ **Explication** :  
âœ” Une transaction peut inclure plusieurs collections (`commandes`, `stock`, `factures`).  
âœ” Si **une seule opÃ©ration Ã©choue**, tout est annulÃ©.  

---

## **5ï¸âƒ£ Bonnes pratiques pour les transactions**  

âœ” **Utiliser des transactions uniquement si nÃ©cessaire** : elles ralentissent les performances.  
âœ” **Limiter la durÃ©e des transactions** pour Ã©viter les conflits de verrouillage.  
âœ” **Ne pas utiliser les transactions pour de la lecture seule** (utiliser des index Ã  la place).  
âœ” **Sâ€™assurer que MongoDB est en mode Replica Set** (transactions non disponibles en standalone).  

---

## **6ï¸âƒ£ Utilisation de MongoDB Compass pour les transactions**  

MongoDB Compass ne prend pas en charge les transactions directement, mais il permet de :  

1ï¸âƒ£ **CrÃ©er des documents manuellement** pour simuler une transaction.  
2ï¸âƒ£ **VÃ©rifier la cohÃ©rence des donnÃ©es** aprÃ¨s exÃ©cution de transactions en Shell.  
3ï¸âƒ£ **Utiliser `Aggregations`** pour valider les rÃ©sultats aprÃ¨s `commitTransaction()`.  

---

## **ğŸ› ï¸ ActivitÃ©s pratiques**  

### **Exercice 1 : Transactions dans un systÃ¨me bancaire**  
ğŸ“Œ **Objectif** : Simuler une **opÃ©ration de virement** entre deux comptes.  

1ï¸âƒ£ **CrÃ©er une collection `comptes`** avec les champs : `titulaire`, `solde`.  
2ï¸âƒ£ **InsÃ©rer deux comptes bancaires** avec un solde initial de 1000â‚¬.  
3ï¸âƒ£ **Ã‰crire une transaction** pour :  
   - DÃ©biter **100â‚¬ du compte A**.  
   - CrÃ©diter **100â‚¬ sur le compte B**.  
4ï¸âƒ£ **Tester avec une erreur** pour vÃ©rifier que tout est annulÃ© si le dÃ©bit dÃ©passe le solde.  
5ï¸âƒ£ **Afficher les comptes** avant et aprÃ¨s la transaction.  

---

## **ğŸ“– Questions de rÃ©vision**  

âœ” Pourquoi les transactions sont-elles importantes en MongoDB ?  
âœ” Quelle est la diffÃ©rence entre `commitTransaction()` et `abortTransaction()` ?  
âœ” Comment MongoDB gÃ¨re-t-il les transactions multi-collections ?  
âœ” Quels sont les cas dâ€™usage typiques des transactions en NoSQL ?  
